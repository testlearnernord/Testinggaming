<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover"/>
<title>Poopboy ‚Äî Farming RPG</title>
<style>
  :root { --safe-bottom: env(safe-area-inset-bottom, 0px); --safe-top: env(safe-area-inset-top, 0px); }
  html, body { margin:0; padding:0; background:#0b0f12; color:#f2f2f2; font-family: system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji", sans-serif; height:100%; }
  #canvas { display:block; width:100vw; height:100vh; touch-action:none; background:#0b0f12; }

  /* HUD */
  #hudbar{
    position:fixed; top:calc(0px + var(--safe-top)); left:0; right:0;
    display:flex; align-items:center; gap:.5rem; flex-wrap:wrap;
    padding:.5rem .6rem; z-index:20;
    background:linear-gradient(180deg, rgba(0,0,0,.55), rgba(0,0,0,.25));
    backdrop-filter: blur(8px); border-bottom:1px solid #2a3440;
    overflow-x:auto; -webkit-overflow-scrolling:touch;
  }
  .pill { display:flex; align-items:center; gap:.4rem; padding:.4rem .6rem; border:1px solid #33404d; border-radius:12px; background:#18222c; font-weight:700; }
  .pill b { font-weight:800; }
  #dayhint { margin-left:auto; opacity:.95; font-weight:600; min-width:max-content; }
  #clockwrap { display:flex; align-items:center; gap:.35rem; font-weight:800; min-width:max-content; }
  @media (max-width: 390px){ .pill{ padding:.35rem .5rem; } #clockwrap{ font-size:.95em; } }

  /* Inventar-Highlight-Slots */
  .slot { cursor:pointer; user-select:none; }
  .slot.active { border-color:#ffcc00; box-shadow:0 0 8px rgba(255,204,0,.7); }

  /* Joystick */
  #stick { position:fixed; bottom: calc(2.2rem + var(--safe-bottom)); left:1rem; width:140px; height:140px; z-index:11; }
  .ring { position:absolute; inset:0; border-radius:999px; background:rgba(24,34,44,.55); border:2px solid #33404d; }
  .knob { position:absolute; width:64px; height:64px; left:38px; top:38px; border-radius:999px; background:#1f2937; border:2px solid #556070; box-shadow: inset 0 0 8px rgba(0,0,0,.4); touch-action:none; }

  /* Kontext-Button */
  #contextBtn{
    position:fixed;
    right:max(1rem, env(safe-area-inset-right));
    bottom:calc(1rem + var(--safe-bottom));
    width:88px; height:88px;
    font-size:40px;
    border-radius:999px;
    background:#2563eb; color:#fff; border:none;
    box-shadow:0 4px 0 #1b48a8;
    z-index:12;
  }
  #contextBtn:disabled{ background:#3b4551; box-shadow:none; opacity:.6; }

  /* Helpers */
  #helpers{ position:fixed; left:.6rem; top:calc(3.2rem + var(--safe-top)); display:flex; gap:.5rem; z-index:50; }
  .btn-ghost { background:#1a242e; border:1px solid #2f3b48; color:#d7e7ff; border-radius:10px; padding:.6rem .9rem; font-weight:800; }

  /* Toast */
  #toast { position:fixed; bottom: calc(10.5rem + var(--safe-bottom)); left:50%; transform: translateX(-50%); background:rgba(0,0,0,.85); padding:.7rem 1rem; border-radius:.9rem; opacity:0; transition: opacity .3s; font-weight:800; z-index:25; }

  /* Modal ‚Äì H√§ndler/Build/Cheat */
  #modalBackdrop { position:fixed; inset:0; background:rgba(0,0,0,.5); opacity:0; pointer-events:none; transition:opacity .2s; z-index:40; }
  #modal { position:fixed; left:50%; top:50%; transform:translate(-50%,-50%) scale(.98); width:min(94vw, 560px); background:#0f141a; border:2px solid #3a2a18; border-radius:14px; box-shadow:0 20px 60px rgba(0,0,0,.5), inset 0 0 0 4px #22170d; opacity:0; pointer-events:none; transition:opacity .2s, transform .2s; z-index:41; }
  #modal.open, #modalBackdrop.open { opacity:1; pointer-events:auto; }
  #modal.open { transform:translate(-50%,-50%) scale(1); }
  .modal-head { display:flex; gap:.8rem; align-items:center; padding:12px 14px; border-bottom:2px solid #3a2a18; background:linear-gradient(180deg,#1a1f25,#12171c); }
  .portrait { width:56px; height:56px; border-radius:8px; background:#2b1c11; display:grid; place-items:center; font-size:28px; border:2px solid #6b4630; }
  .m-title { font-weight:900; font-size:18px; }
  .m-sub { opacity:.8; font-size:13px; }
  .shoplist { max-height:58vh; overflow:auto; padding:10px 14px; display:flex; flex-direction:column; gap:10px; }
  .item { display:flex; align-items:center; gap:10px; padding:10px; border:1px solid #2a3440; border-radius:10px; background:#121a22; }
  .i-ic { width:44px; height:44px; border-radius:8px; display:grid; place-items:center; font-size:24px; background:#19222b; border:1px solid #2c3743; }
  .i-body { flex:1; }
  .i-name { font-weight:800; }
  .i-desc { opacity:.85; font-size:12px; }
  .i-price { font-weight:800; }
  .i-col { display:flex; align-items:center; gap:10px; }

  /* Cooking overlay */
  #cookOverlay { position:fixed; inset:0; pointer-events:none; }
</style>
</head>
<body>
<canvas id="canvas"></canvas>

<!-- HUD -->
<div id="hudbar">
  <span id="clockwrap" class="pill">üïí <b id="clock">06:00</b> <span id="dayicon">üåû</span></span>
  <span class="pill">‚ù§Ô∏è <b id="v_hp">3</b></span>
  <span class="pill">üí∂ <b id="v_euro">0</b></span>

  <!-- aktivierbare Slots -->
  <span class="pill slot" data-item="poop">üí© <b id="v_poop">0</b></span>
  <span class="pill slot" data-item="cabbageSeed">ü•¨ <b id="v_cabbageSeed">0</b></span>
  <span class="pill slot" data-item="stone">ü™® <b id="v_stone">0</b></span>

  <span class="pill">üåΩ <b id="v_corn">0</b></span>
  <span class="pill">ü•¨ <b id="v_cabbage">0</b></span>
  <span class="pill">üíß <b id="v_can">0/0</b></span>

  <div id="dayhint">Tag: Anbau & Handel ge√∂ffnet.</div>
</div>

<!-- Kontext-Button -->
<button id="contextBtn" aria-label="Aktion" disabled>‚ùì</button>

<!-- Joystick -->
<div id="stick" aria-label="Joystick"><div class="ring"></div><div class="knob" id="knob"></div></div>

<!-- Toast -->
<div id="toast"></div>

<!-- Modal (Shops & Cheats & Build) -->
<div id="modalBackdrop"></div>
<div id="modal">
  <div class="modal-head">
    <div class="portrait" id="m_portrait">üßë‚Äçüåæ</div>
    <div><div class="m-title" id="m_title">H√§ndler</div><div class="m-sub" id="m_sub">√ñffnungszeiten: Tag</div></div>
  </div>
  <div class="shoplist" id="m_list"></div>
  <div style="display:flex;justify-content:flex-end;gap:10px;padding:10px 14px;border-top:2px solid #3a2a18;">
    <button class="btn-ghost" id="m_close">Schlie√üen</button>
  </div>
</div>

<!-- Helpers -->
<div id="helpers">
  <button class="btn-ghost" id="btnCenter">üîé Zentrieren</button>
  <button class="btn-ghost" id="btnReset">‚ôªÔ∏è Neustart</button>
</div>

<script>
/* ===== TINY SFX ENGINE (no files) ===== */
const SFX = (() => {
  let ctx, unlocked = false, queue = [];
  function ensure(){ if(!ctx) ctx = new (window.AudioContext||window.webkitAudioContext)(); if (ctx.state==='suspended') ctx.resume(); return ctx; }
  function unlock(){ ensure(); unlocked = true; const q = queue.slice(); queue.length = 0; q.forEach(fn=>fn()); }
  function epicSpawnCore(){
    const c = ensure(), now = c.currentTime;
    // tiefer "Drum"-Schlag
    let o1=c.createOscillator(), g1=c.createGain();
    o1.type='sine'; o1.frequency.setValueAtTime(90, now); o1.frequency.exponentialRampToValueAtTime(45, now+0.45);
    g1.gain.setValueAtTime(0.0001, now); g1.gain.linearRampToValueAtTime(0.7, now+0.02); g1.gain.exponentialRampToValueAtTime(0.0001, now+0.55);
    o1.connect(g1); g1.connect(c.destination); o1.start(now); o1.stop(now+0.6);
    // leichter Echo-Schlag
    let o2=c.createOscillator(), g2=c.createGain();
    o2.type='sine'; o2.frequency.setValueAtTime(60, now+0.12);
    g2.gain.setValueAtTime(0.0001, now+0.12); g2.gain.linearRampToValueAtTime(0.35, now+0.16); g2.gain.exponentialRampToValueAtTime(0.0001, now+0.45);
    o2.connect(g2); g2.connect(c.destination); o2.start(now+0.12); o2.stop(now+0.5);
    // aufsteigende Note
    let o3=c.createOscillator(), g3=c.createGain();
    o3.type='triangle'; o3.frequency.setValueAtTime(200, now+0.18); o3.frequency.linearRampToValueAtTime(420, now+0.48);
    g3.gain.setValueAtTime(0.0001, now+0.18); g3.gain.linearRampToValueAtTime(0.25, now+0.22); g3.gain.exponentialRampToValueAtTime(0.0001, now+0.6);
    o3.connect(g3); g3.connect(c.destination); o3.start(now+0.18); o3.stop(now+0.65);
  }
  const play = {
    spawn: ()=>{ if(!unlocked){ queue.push(epicSpawnCore); return; } epicSpawnCore(); }
  };
  // public
  return { ensure, unlock, play };
})();
// iOS/Safari: beim ersten Touch Audio freischalten und ausstehende Sounds abspielen
window.addEventListener('touchstart', () => { SFX.unlock(); }, {once:true, passive:true});
window.addEventListener('pointerdown', () => { SFX.unlock(); }, {once:true});
</script>

<script>
(() => {
  // ========= CONFIG =========
  const TILE = 48;
  const MAP_W = 40, MAP_H = 24;

  // Economy & Timers
  const CORN_TIME = 40_000;             // 40s
  const CORN_CHANCE = 0.60;             // 60% chance
  const CABBAGE_TIME = 120_000;         // 120s
  const CABBAGE_WATERED_TOTAL = 40_000; // watered -> 40s total
  const ERD_POOP_CHANCE = 0.125;        // 12.5% Poop bei Erdbrocken

  const DAY_TOTAL_MS = 180_000;         // 3 min
  const DAYLIGHT_MS  = 120_000;         // 2 min day, 1 min night

  const SPEED_BASE = 3.6;
  const SHOES_MULT = 1.35;

  // Rocks
  const ROCK_SPAWN = 200;
  const ROCK_MAX   = 90;
  const START_ROCKS = 40;
  const DIRT_RATIO = 0.35;

  // Interact distances
  const STONE_R   = TILE * 0.36;
  const NEAR_DIST = TILE * 1.2;
  const PICK_DIST = TILE * 0.95;
  const PLANT_DIST = TILE * 0.8;
  const POND_DIST  = TILE * 2.0;

  // Farm fence + gate
  const FARM_W = 6, FARM_H = 4;
  const FENCE_THICK = 12;
  const GATE_WIDTH = TILE * 1.2;

  // Monster/Combat
  const MONSTER_SPAWN_INTERVAL = 180;
  const MONSTER_MAX = 4;
  const MONSTER_SPEED_FACTOR = 0.5;
  const MONSTER_TOUCH_KNOCKBACK = 28;
  const MONSTER_DAMAGE_COOLDOWN = 1200; // ms i-frames
  const BULLET_SPEED = 7.5;
  const BULLET_LIFE = 1600;             // ms

  // ========= TIME SYSTEM =========
  const time = {
    scale: 1, t0: performance.now(), offset: 0,
    now(){ return (performance.now() - this.t0) * this.scale + this.offset; },
    setScale(s){ const cur = this.now(); this.t0 = performance.now(); this.offset = cur; this.scale = s; }
  };

  // Verkaufspreise f√ºr gekochte Items
  const COOK_PRICE = {
    corn:    { normal: 2,  rare: 3,  epic: 5  },
    cabbage: { normal: 10, rare: 14, epic: 20 }
  };

  // ========= STATE =========
  const camera = { x:0, y:0 };
  const state = {
    mode: "play",
    player: { x: TILE*2, y: TILE*2, r: TILE*0.38, faceX:1, faceY:0 },
    speedMult: 1.0,
    merchant: { x: TILE*(MAP_W-5), y: TILE*(MAP_H-5), name: "Fecalfred" },
    artist:   { x: TILE*6,         y: TILE*7,         name: "Berta Brown" },
    cheat:    { x: TILE*(MAP_W-3), y: TILE*(MAP_H/2), name: "Stefan Spielverderber" },
    pond:     { x: TILE*(MAP_W-3), y: TILE*(5) }, // etwas tiefer
    farmRect: null, fenceRects: [], houseRect: null,
    clearingRect: null,

    toolbox: { x: 0, y: 0 },
    shack:   { built:false, safeRect:null, firePos:null, clearingUpgrade:false },

    stones: [],     // nat√ºrliche Steine/Erdbrocken
    blocks: [],     // platzierte Steine

    plants: [],     // Pflanzen
    inv: {
      stone:0, poop:0, corn:0, cabbage:0, euro:0,
      hasCan:false, can:0, canMax:13, hasShoes:false, cabbageSeed:0,
      cookedCornN:0, cookedCornR:0, cookedCornE:0,
      cookedCabbN:0, cookedCabbR:0, cookedCabbE:0
    },
    smoke: [],
    spawnFx: [],   // Staubpartikel
    frame: 0,
    keys: new Set(),
    joy: { id:null, cx:0, cy:0, vx:0, vy:0, dead:10, max:50 },
    rngSeed: (Date.now() ^ 0x9e3779b9) >>> 0,
    debugCenter: true,
    isDay: true, wasDayLastFrame: true,
    clockText: "06:00",
    lastTimeBase: time.now(),

    // Combat
    hp: 3, invincibleUntil: 0, god:false,
    monsters: [], bullets: [],

    // UI
    activeSeed: null, // "poop" | "cabbageSeed" | "stone" | null

    // Cooking
    cook: { active:false, item:null, round:0, successes:0, speed:0, dir:1, pos:0, green:[0.4,0.6] }
  };

  function rand(){ let x=state.rngSeed; x^=x<<13; x^=x>>>17; x^=x<<5; state.rngSeed=x>>>0; return (state.rngSeed%1_000_000)/1_000_000; }

  // ========= CANVAS =========
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d', { alpha:false });
  function resize(){ const dpr=Math.max(1,window.devicePixelRatio||1); const w=Math.floor(window.innerWidth), h=Math.floor(window.innerHeight);
    canvas.style.width=w+"px"; canvas.style.height=h+"px"; canvas.width=Math.floor(w*dpr); canvas.height=Math.floor(h*dpr); ctx.setTransform(dpr,0,0,dpr,0,0); }
  window.addEventListener('resize', resize, {passive:true}); resize();

  // ========= UI refs =========
  const toast = document.getElementById('toast');
  const lblClock = document.getElementById('clock');
  const lblIcon  = document.getElementById('dayicon');
  const dayHint  = document.getElementById('dayhint');
  const vStone = document.getElementById('v_stone');
  const vPoop  = document.getElementById('v_poop');
  const vCorn  = document.getElementById('v_corn');
  const vCabb  = document.getElementById('v_cabbage');
  const vEuro  = document.getElementById('v_euro');
  const vCan   = document.getElementById('v_can');
  const vHp    = document.getElementById('v_hp');
  const vSeed  = document.getElementById('v_cabbageSeed');
  const contextBtn = document.getElementById('contextBtn');

  const btnCenter = document.getElementById('btnCenter');
  const btnReset  = document.getElementById('btnReset');

  const modalBackdrop = document.getElementById('modalBackdrop');
  const modal = document.getElementById('modal');
  const mPortrait = document.getElementById('m_portrait');
  const mTitle    = document.getElementById('m_title');
  const mSub      = document.getElementById('m_sub');
  const mList     = document.getElementById('m_list');
  const mClose    = document.getElementById('m_close');

  // ========= Helpers =========
  const say=(m)=>{ toast.textContent=m; toast.style.opacity='1'; clearTimeout(say._t); say._t=setTimeout(()=>toast.style.opacity='0',1700); };
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const dist=(ax,ay,bx,by)=>Math.hypot(ax-bx, ay-by);
  const isNear = (obj, d=NEAR_DIST)=> dist(state.player.x,state.player.y,obj.x,obj.y) < d;

  // ---- Zeit / Uhr ----
  function updateClock(){
    const elapsed = (time.now() - state.lastTimeBase) % DAY_TOTAL_MS;
    state.isDay = elapsed < DAYLIGHT_MS;
    const hoursFloat = 24 * (elapsed / DAY_TOTAL_MS);
    const hh = Math.floor(hoursFloat), mm = Math.floor((hoursFloat - hh) * 60);
    state.clockText = `${String(hh).padStart(2,'0')}:${String(mm).padStart(2,'0')}`;
    lblClock.textContent = state.clockText;
    lblIcon.textContent = state.isDay ? "üåû" : "üåô";
    dayHint.textContent = state.isDay ? "Tag: Anbau & Handel ge√∂ffnet." : "Nacht: Monster unterwegs!";

    if (state.wasDayLastFrame && !state.isDay) state._monsterSpawnTick = 0;
    if (!state.wasDayLastFrame && state.isDay) { if (state.monsters.length) say("üí• Die Sonne verbrennt die Monster!"); state.monsters.length = 0; }
    state.wasDayLastFrame = state.isDay;
  }

  function updateHUD(){
    vStone.textContent = state.inv.stone;
    vPoop .textContent = state.inv.poop;
    vCorn .textContent = state.inv.corn;
    vCabb .textContent = state.inv.cabbage;
    vEuro .textContent = state.inv.euro.toFixed(0);
    vCan  .textContent = state.inv.hasCan ? `${state.inv.can}/${state.inv.canMax}` : "0/0";
    vHp.textContent = state.hp + (state.god ? " (üëë)" : "");
    if (vSeed) vSeed.textContent = state.inv.cabbageSeed;
  }

  // Saat/Stein-Auswahl
  document.querySelectorAll('.slot').forEach(slot=>{
    slot.addEventListener('click', ()=>{
      const item = slot.dataset.item;
      if (state.activeSeed === item) { state.activeSeed=null; slot.classList.remove('active'); }
      else {
        state.activeSeed = item;
        document.querySelectorAll('.slot').forEach(s=>s.classList.remove('active'));
        slot.classList.add('active');
      }
    });
  });

  // ========= Areas: farm, fence, houses, pond, clearing =========
  (function setupAreas(){
    const hx = state.merchant.x - TILE, hy = state.merchant.y - TILE;
    state.houseRect = { x1: hx - TILE*0.5, y1: hy - TILE*0.5, x2: hx - TILE*0.5 + TILE*2, y2: hy - TILE*0.5 + TILE*2 };

    const left = Math.max(TILE, state.merchant.x - TILE*(FARM_W+2));
    const top  = Math.max(TILE, state.merchant.y - TILE*(FARM_H+2));
    state.farmRect = { x1:left, y1:top, x2:left+FARM_W*TILE, y2:top+FARM_H*TILE };

    // Lichtung links der Farm (4x3 Tiles)
    const CLEAR_W=4, CLEAR_H=3;
    const cx2 = Math.max(TILE, state.farmRect.x1 - TILE*(CLEAR_W + 2));
    const cy2 = clamp(state.farmRect.y1 + TILE, TILE, MAP_H*TILE - TILE*(CLEAR_H+2));
    state.clearingRect = { x1:cx2, y1:cy2, x2:cx2 + CLEAR_W*TILE, y2:cy2 + CLEAR_H*TILE };

    // Toolbox in die Mitte
    const ccx = (state.clearingRect.x1 + state.clearingRect.x2) / 2;
    const ccy = (state.clearingRect.y1 + state.clearingRect.y2) / 2;
    state.toolbox.x = ccx; state.toolbox.y = ccy;
  })();

  function circleRectCollision(px,py,r, rc){
    const cx = Math.max(rc?.x1 ?? -1e9, Math.min(px, rc?.x2 ?? 1e9));
    const cy = Math.max(rc?.y1 ?? -1e9, Math.min(py, rc?.y2 ?? 1e9));
    return Math.hypot(px - cx, py - cy) < r;
  }
  const collidesHouse = (x,y)=> circleRectCollision(x,y,state.player.r, state.houseRect);
  const collidesFence = (x,y)=> state.fenceRects?.some(rc => circleRectCollision(x,y,state.player.r, rc));
  const collidesAnyRect = (x,y)=> collidesHouse(x,y) || collidesFence(x,y);
  const inFarm = (x,y)=> { const f=state.farmRect; return x>=f.x1&&x<=f.x2&&y>=f.y1&&y<=f.y2; };
  function insideRect(x,y,rc){ return x>=rc.x1 && x<=rc.x2 && y>=rc.y1 && y<=rc.y2; }
  function insideRectPt(x,y,rc){ return insideRect(x,y,rc); }
  function makeInsetRect(rc, inset){ return { x1: rc.x1+inset, y1: rc.y1+inset, x2: rc.x2-inset, y2: rc.y2-inset }; }

  // ==== Blocking/Kollisionen ====
  function isBlockedCircle(x,y,r){
    if (collidesAnyRect(x,y)) return true;
    for (const s of state.stones){ if (s.type==='stone' && Math.hypot(x - s.x, y - s.y) < (r + STONE_R)) return true; }
    for (const b of state.blocks){ if (Math.hypot(x - b.x, y - b.y) < (r + STONE_R)) return true; }
    return false;
  }

  // ========= Rocks =========
  function randomEmptyTile(){ return { x: Math.floor(rand()*MAP_W)*TILE + TILE/2, y: Math.floor(rand()*MAP_H)*TILE + TILE/2 }; }
  function canSpawnRockAt(x,y){
    if (collidesAnyRect(x,y)) return false;
    for (const b of state.blocks) if (dist(x,y,b.x,b.y) < STONE_R*2) return false;
    for (const s of state.stones) if (dist(x,y,s.x,s.y) < STONE_R*2) return false;
    for (const p of state.plants) if (dist(x,y,p.x,p.y) < STONE_R*2) return false;
    if (insideRect(x,y,state.clearingRect)) return false;
    if (state.shack.built && insideRectPt(x,y, state.shack.safeRect)) return false;
    return true;
  }
  function spawnRock(){
    let tries = 80;
    while (tries-- > 0){
      const p = randomEmptyTile();
      if (!canSpawnRockAt(p.x,p.y)) continue;
      const type = (rand() < DIRT_RATIO) ? 'dirt' : 'stone';
      state.stones.push({x:p.x, y:p.y, type});
      return;
    }
  }
  for(let i=0;i<START_ROCKS;i++) spawnRock();

  // ========= Plants =========
  function snapToTile(x,y){ return { tx: Math.round(x/TILE)*TILE + TILE/2, ty: Math.round(y/TILE)*TILE + TILE/2 }; }

  function plantPoop(){
    if (!state.isDay) return say("Nacht: Kein Anbau.");
    if (state.inv.poop<=0) return say("Du brauchst üí©.");
    if (!inFarm(state.player.x, state.player.y)) return say("Nur im eingez√§unten Feld!");
    const {tx,ty} = snapToTile(state.player.x, state.player.y);
    if (state.plants.some(p => dist(p.x,p.y,tx,ty) < TILE*0.25)) return say("Hier w√§chst bereits etwas.");
    if (isBlockedCircle(tx,ty, TILE*0.2)) return say("Hier ist blockiert.");
    state.inv.poop--;
    const now = time.now();
    state.plants.push({ x:tx, y:ty, type:'corn', plantedAt:now, readyAt:now + CORN_TIME, stage:0, watered:false });
    updateHUD(); say("üí© gesetzt ‚Äì Mais sprie√üt‚Ä¶ (40s)"); save();
  }
  function plantCabbage(){
    if (!state.isDay) return say("Nacht: Kein Anbau.");
    if (state.inv.cabbageSeed<=0) return say("Keine ü•¨-Saat.");
    if (!inFarm(state.player.x, state.player.y)) return say("Nur im eingez√§unten Feld!");
    const {tx,ty} = snapToTile(state.player.x, state.player.y);
    if (state.plants.some(p => dist(p.x,p.y,tx,ty) < TILE*0.25)) return say("Hier w√§chst bereits etwas.");
    if (isBlockedCircle(tx,ty, TILE*0.2)) return say("Hier ist blockiert.");
    state.inv.cabbageSeed--;
    const now = time.now();
    state.plants.push({ x:tx, y:ty, type:'cabbage', plantedAt:now, readyAt:now + CABBAGE_TIME, stage:0, watered:false });
    updateHUD(); say("ü•¨ Saat gelegt ‚Äì Kohl w√§chst‚Ä¶ (120s)"); save();
  }
  function findNearbyPlant(){
    let best=null, bestD=9999;
    for (const p of state.plants){
      const d = dist(p.x,p.y,state.player.x,state.player.y);
      if (d<PLANT_DIST && d<bestD) { best=p; bestD=d; }
    }
    return best;
  }
  function waterPlant(){
    if (!state.inv.hasCan) return say("Keine Gie√ükanne.");
    if (state.inv.can<=0) return say("Gie√ükanne leer ‚Äì am Teich auff√ºllen.");
    const p = findNearbyPlant();
    if (!p) return say("Geh n√§her an die Pflanze.");
    if (p.stage>=3) return say("Diese Pflanze ist reif.");
    if (p.watered) return say("Schon gegossen.");
    p.watered = true;
    if (p.type==='corn'){
      const now = time.now();
      p.readyAt = Math.max(now + 10_000, p.readyAt - 30_000);
      say("üíß Mais bew√§ssert: -30s.");
    } else {
      p.readyAt = Math.min(p.readyAt, p.plantedAt + CABBAGE_WATERED_TOTAL);
      say("üíß Kohl bew√§ssert: Gesamtzeit 40s.");
    }
    state.inv.can--; updateHUD(); save();
  }
  function harvestPlant(){
    const p = findNearbyPlant();
    if (!p) return say("Geh n√§her an die Pflanze.");
    if (p.stage<3) return say("Noch nicht reif.");
    if (p.type==='corn'){ if (rand() < CORN_CHANCE){ state.inv.corn++; say("üåΩ +1 Mais"); } else say("üåΩ Ernte fehlgeschlagen."); }
    else { state.inv.cabbage++; say("ü•¨ +1 Kohl"); }
    const i = state.plants.indexOf(p); if (i>=0) state.plants.splice(i,1);
    updateHUD(); save();
  }
  function updatePlants(){
    const now = time.now();
    for (const p of state.plants){
      const t = p.readyAt - now;
      const total = (p.type==='corn') ? CORN_TIME : (p.watered ? CABBAGE_WATERED_TOTAL : CABBAGE_TIME);
      const prog = clamp(1 - (t/total), 0, 1);
      if (prog < 0.33) p.stage = 0;
      else if (prog < 0.66) p.stage = 1;
      else if (prog < 0.99) p.stage = 2;
      else p.stage = 3;
    }
  }

  // ========= Shops / Build / Cheat =========
  function openShop(kind){
    if (kind!=='cheat' && kind!=='build' && !state.isDay){ say("Geschlossen ‚Äì Nacht."); return; }
    if (kind==='fecal' && !isNear(state.merchant)) return say("Geh n√§her zu Fecalfred.");
    if (kind==='berta' && !isNear(state.artist)) return say("Geh n√§her zu Berta Brown.");
    if (kind==='cheat' && !isNear(state.cheat)) return say("Geh n√§her zu Stefan.");
    if (kind==='build' && !isNear(state.toolbox)) return say("Geh zum Werkzeugkasten.");
    mList.innerHTML = "";
    if (kind==='fecal'){
      mPortrait.textContent = "üßë‚Äçüåæ"; mTitle.textContent = "Fecalfred"; mSub.textContent = "Tausch & Saat (tags√ºber)";
      addItem({ icon:"üîÅ", name:"Tausch: 10 ü™® ‚Üí 1 üí©", desc:"Steine gegen D√ºnger.", price:"‚Äî", actionText:"Tauschen", disabled: state.inv.stone<10,
        onClick:()=>{ state.inv.stone-=10; state.inv.poop+=1; updateHUD(); say("10 ü™® ‚Üí 1 üí©"); save(); renderShopBody(); } });
      addItem({ icon:"ü•¨", name:"Kohl-Saat", desc:"F√ºr dein Feld.", price:"4 ‚Ç¨", actionText:"Kaufen", disabled: state.inv.euro<4,
        onClick:()=>{ if (state.inv.euro>=4){ state.inv.euro-=4; state.inv.cabbageSeed++; updateHUD(); say("ü•¨ Saat +1"); save(); renderShopBody(); } } });
      addItem({ icon:"üåΩ", name:"Mais verkaufen", desc:"+1 ‚Ç¨ pro St√ºck.", price:"+1 ‚Ç¨", actionText:"Verkaufen", disabled: state.inv.corn<1,
        onClick:()=>{ if (state.inv.corn>0){ state.inv.corn--; state.inv.euro += 1; updateHUD(); say("üåΩ verkauft: +1 ‚Ç¨"); save(); renderShopBody(); } } });
      addItem({ icon:"ü•¨", name:"Kohl verkaufen", desc:"+7 ‚Ç¨ pro St√ºck.", price:"+7 ‚Ç¨", actionText:"Verkaufen", disabled: state.inv.cabbage<1,
        onClick:()=>{ if (state.inv.cabbage>0){ state.inv.cabbage--; state.inv.euro += 7; updateHUD(); say("ü•¨ verkauft: +7 ‚Ç¨"); save(); renderShopBody(); } } });

      // Verkauf gekochter Items
      const sellCook = (label, countKey, money)=> addItem({
        icon:"üçΩÔ∏è", name:`${label}`, desc:`Verkauf f√ºr ${money} ‚Ç¨`, price:`${money} ‚Ç¨`, actionText:"Verkaufen",
        disabled: state.inv[countKey] < 1,
        onClick:()=>{ state.inv[countKey]--; state.inv.euro += money; updateHUD(); say(`üçΩÔ∏è verkauft: +${money} ‚Ç¨`); save(); renderShopBody(); }
      });
      sellCook("Gekochter Mais (Normal)", "cookedCornN", COOK_PRICE.corn.normal);
      sellCook("Gekochter Mais (Selten)", "cookedCornR", COOK_PRICE.corn.rare);
      sellCook("Gekochter Mais (Episch)", "cookedCornE", COOK_PRICE.corn.epic);
      sellCook("Gekochter Kohl (Normal)", "cookedCabbN", COOK_PRICE.cabbage.normal);
      sellCook("Gekochter Kohl (Selten)", "cookedCabbR", COOK_PRICE.cabbage.rare);
      sellCook("Gekochter Kohl (Episch)", "cookedCabbE", COOK_PRICE.cabbage.epic);

    } else if (kind==='berta') {
      mPortrait.textContent = "üë©‚Äçüé®"; mTitle.textContent = "Berta Brown"; mSub.textContent = "Kunst & Upgrades (tags√ºber)";
      addItem({ icon:"üíß", name:"Gie√ükanne", desc:"Permanent, 13 Nutzungen. Am Teich auff√ºllbar.", price:"5 ‚Ç¨",
        actionText: state.inv.hasCan ? "Gekauft" : "Kaufen", disabled: state.inv.hasCan || state.inv.euro<5,
        onClick:()=>{ if (!state.inv.hasCan && state.inv.euro>=5){ state.inv.hasCan=true; state.inv.euro-=5; state.inv.can=state.inv.canMax; updateHUD(); say("üíß Gie√ükanne gekauft"); save(); renderShopBody(); } } });
      addItem({ icon:"üëü", name:"Schnelle Schuhe", desc:"+35% Laufgeschwindigkeit.", price:"7 ‚Ç¨",
        actionText: state.inv.hasShoes ? "Gekauft" : "Kaufen", disabled: state.inv.hasShoes || state.inv.euro<7,
        onClick:()=>{ if (!state.inv.hasShoes && state.inv.euro>=7){ state.inv.hasShoes=true; state.inv.euro-=7; state.speedMult = SHOES_MULT; updateHUD(); say("üëü Geschwindigkeit +35%"); save(); renderShopBody(); } } });
    } else if (kind==='build') {
      mPortrait.textContent = "üß∞";
      mTitle.textContent    = "Bauplatz ‚Äì Lichtung";
      mSub.textContent      = state.shack.built ? "Shack steht. Du kannst den Bauplatz erweitern." : "Baue erste Struktur";

      if (!state.shack.built) {
        addItem({
          icon:"üõñ", name:"Broken Shack", desc:"Kleine H√ºtte mit Feuer & Bett. Monster meiden die Zone in der Nacht.",
          price:"50 ‚Ç¨", actionText:"Bauen (50‚Ç¨)", disabled: state.inv.euro < 50,
          onClick:()=>{
            if (state.inv.euro >= 50) {
              state.inv.euro -= 50;
              state.shack.built = true;
              state.shack.safeRect = makeInsetRect(state.clearingRect, TILE*0.4);
              const z = state.shack.safeRect; const cx = (z.x1+z.x2)/2, cy = (z.y1+z.y2)/2;
              state.shack.firePos = { x: cx - TILE*0.7, y: cy + TILE*0.4 };
              updateHUD(); save(); say("üõñ Shack gebaut! In der Nacht hier sicher.");
              closeModal();
            }
          }
        });
      } else {
        if (!state.shack.clearingUpgrade) {
          addItem({
            icon:"üìê", name:"Lichtungsplatz erweitern",
            desc:"Vergr√∂√üert den Bauplatz um ~50% ‚Äì mehr Platz f√ºr zuk√ºnftige Strukturen.",
            price:"100 ‚Ç¨", actionText:"Erweitern (100‚Ç¨)",
            disabled: state.inv.euro < 100,
            onClick:()=>{
              if (state.inv.euro >= 100) {
                state.inv.euro -= 100;
                state.shack.clearingUpgrade = true;
                const extra = TILE*1.5;
                state.clearingRect.x1 -= extra; state.clearingRect.y1 -= extra;
                state.clearingRect.x2 += extra; state.clearingRect.y2 += extra;
                state.shack.safeRect = makeInsetRect(state.clearingRect, TILE*0.4);
                const z = state.shack.safeRect; const cx = (z.x1+z.x2)/2, cy = (z.y1+z.y2)/2;
                state.shack.firePos = { x: cx - TILE*0.7, y: cy + TILE*0.4 };
                updateHUD(); save(); say("üìê Lichtung erweitert!");
                closeModal();
              }
            }
          });
        } else {
          addItem({ icon:"üî•", name:"Kochstelle", desc:"Hier kannst du kochen (üç≥).", price:"", actionText:"Okay", disabled:true, onClick:null });
        }
      }

    } else {
      // Stefan Spielverderber ‚Äì Cheat-Men√º
      mPortrait.textContent = "üßô‚Äç‚ôÇÔ∏è"; mTitle.textContent = "Stefan Spielverderber"; mSub.textContent = "Debug/QA Tools (nur Test)";
      addItem({ icon:"üí∂", name:"+50 ‚Ç¨", desc:"Geld f√ºr Tests.", price:"", actionText:"+50 ‚Ç¨", disabled:false,
        onClick:()=>{ state.inv.euro+=50; updateHUD(); say("üí∂ +50"); }});
      addItem({ icon:"ü™®", name:"+20 Steine", desc:"F√ºr Barrikaden/Sch√ºsse.", price:"", actionText:"+20", disabled:false,
        onClick:()=>{ state.inv.stone+=20; updateHUD(); say("ü™® +20"); }});
      addItem({ icon:"üí©", name:"+10 Poop", desc:"Schneller Mais.", price:"", actionText:"+10", disabled:false,
        onClick:()=>{ state.inv.poop+=10; updateHUD(); say("üí© +10"); }});
      addItem({ icon:"ü•¨", name:"+10 Kohl-Saat", desc:"F√ºr Felder.", price:"", actionText:"+10", disabled:false,
        onClick:()=>{ state.inv.cabbageSeed+=10; updateHUD(); say("ü•¨ +10"); }});
      addItem({ icon:"üíß", name:"Gie√ükanne geben & f√ºllen", desc:"Instant Can 13/13.", price:"", actionText:"Give/Fill", disabled:false,
        onClick:()=>{ state.inv.hasCan=true; state.inv.can=state.inv.canMax; updateHUD(); say("üíß Can 13/13"); }});
      addItem({ icon: state.god?"üõ°Ô∏è":"üó°Ô∏è", name:"Godmode", desc:"Unverwundbar umschalten.", price:"", actionText: state.god?"AUS":"AN", disabled:false,
        onClick:()=>{ state.god=!state.god; updateHUD(); renderShopBody(); say(state.god?"üëë Godmode an":"üõ°Ô∏è Godmode aus"); }});
      addItem({ icon:"‚è±Ô∏è", name:"Zeitfaktor", desc:"0.5√ó / 1.5√ó / 2√ó / 3√ó", price:"", actionText:"0.5√ó", disabled:false,
        onClick:()=>{ time.setScale(0.5); say("‚è±Ô∏è Zeit 0.5√ó"); }});
      addItem({ icon:"‚è±Ô∏è", name:"Zeitfaktor", desc:"Schneller", price:"", actionText:"1.5√ó", disabled:false,
        onClick:()=>{ time.setScale(1.5); say("‚è±Ô∏è Zeit 1.5√ó"); }});
      addItem({ icon:"‚è±Ô∏è", name:"Zeitfaktor", desc:"Noch schneller", price:"", actionText:"2√ó", disabled:false,
        onClick:()=>{ time.setScale(2); say("‚è±Ô∏è Zeit 2√ó"); }});
      addItem({ icon:"‚è±Ô∏è", name:"Zeitfaktor", desc:"Turbo", price:"", actionText:"3√ó", disabled:false,
        onClick:()=>{ time.setScale(3); say("‚è±Ô∏è Zeit 3√ó"); }});
      addItem({ icon:"üåû", name:"Zu Tag wechseln", desc:"Killt Monster.", price:"", actionText:"Tag", disabled:false,
        onClick:()=>{ state.lastTimeBase = time.now() - 0; state.monsters.length=0; state.wasDayLastFrame=false; say("üåû Tag!"); }});
      addItem({ icon:"üåô", name:"Zu Nacht wechseln", desc:"Spawn aktiviert.", price:"", actionText:"Nacht", disabled:false,
        onClick:()=>{ state.lastTimeBase = time.now() - (DAYLIGHT_MS - 1); state.wasDayLastFrame=true; say("üåô Nacht!"); }});
    }
    function renderShopBody(){ openShop(kind); }
    openModal();
  }
  function addItem({icon,name,desc,price,actionText,disabled,onClick}){
    const row = document.createElement('div'); row.className = "item";
    row.innerHTML = `<div class="i-ic">${icon}</div><div class="i-body"><div class="i-name">${name}</div><div class="i-desc">${desc}</div></div><div class="i-col"><div class="i-price">${price||""}</div><button class="btn-ghost"${disabled?' disabled':''}>${actionText}</button></div>`;
    const btn = row.querySelector('button'); if (!disabled && onClick) btn.addEventListener('click', onClick); mList.appendChild(row);
  }
  function openModal(){ modal.classList.add('open'); modalBackdrop.classList.add('open'); }
  function closeModal(){ modal.classList.remove('open'); modalBackdrop.classList.remove('open'); }
  mClose.addEventListener('click', closeModal); modalBackdrop.addEventListener('click', closeModal);

  // ========= Cooking =========
  function openCookMenu(){
    if (!state.shack.built || !state.shack.firePos) return say("Keine Kochstelle.");
    mList.innerHTML = "";
    mPortrait.textContent = "üç≥"; mTitle.textContent = "Kochstelle"; mSub.textContent = "W√§hle ein Rezept (3 Runden Timing)";
    const canCorn = state.inv.corn > 0;
    const canCabb = state.inv.cabbage > 0;
    addItem({ icon:"üåΩ", name:"Gekochter Mais", desc:"3x im gr√ºnen Bereich stoppen.\n1 Treffer: Selten, 2-3: Episch", price:"-1 Mais", actionText:"Kochen", disabled: !canCorn,
      onClick:()=>{ closeModal(); startCooking('corn'); } });
    addItem({ icon:"ü•¨", name:"Gekochter Kohl", desc:"3x im gr√ºnen Bereich stoppen.\n1 Treffer: Selten, 2-3: Episch", price:"-1 Kohl", actionText:"Kochen", disabled: !canCabb,
      onClick:()=>{ closeModal(); startCooking('cabbage'); } });
    openModal();
  }
  function startCooking(item){
    state.mode = "cook";
    state.cook.active = true;
    state.cook.item = item;
    state.cook.round = 1;
    state.cook.successes = 0;
    state.cook.speed = 0.012 + rand()*0.006;
    state.cook.dir = 1;
    state.cook.pos = 0.0;
    randomizeGreen();
  }
  function randomizeGreen(){
    const w = 0.18 + rand()*0.08;
    const start = rand()*(1-w)*0.98 + 0.01;
    state.cook.green = [start, start + w];
  }
  function stopCookingHit(){
    if (!state.cook.active) return;
    const p = state.cook.pos;
    const [a,b] = state.cook.green;
    const perfect = (p >= a && p <= b);
    if (perfect) {/* optional cook sfx */} else {/* optional miss sfx */ }
    if (perfect) state.cook.successes++;
    if (state.cook.round >= 3){ finishCooking(); }
    else { state.cook.round++; state.cook.speed *= 1.18; state.cook.dir = (rand()<0.5)? -1 : 1; randomizeGreen(); }
  }
  function finishCooking(){
    const it = state.cook.item;
    if (it==='corn'){
      if (state.inv.corn <= 0){ say("Kein Mais im Inventar."); abortCooking(); return; }
      state.inv.corn--;
      const s = state.cook.successes;
      if (s>=2) state.inv.cookedCornE++;
      else if (s>=1) state.inv.cookedCornR++;
      else state.inv.cookedCornN++;
      say(`üçΩÔ∏è Gekochter Mais (${s>=2?'Episch':(s>=1?'Selten':'Normal')})`);
    } else {
      if (state.inv.cabbage <= 0){ say("Kein Kohl im Inventar."); abortCooking(); return; }
      state.inv.cabbage--;
      const s = state.cook.successes;
      if (s>=2) state.inv.cookedCabbE++;
      else if (s>=1) state.inv.cookedCabbR++;
      else state.inv.cookedCabbN++;
      say(`üçΩÔ∏è Gekochter Kohl (${s>=2?'Episch':(s>=1?'Selten':'Normal')})`);
    }
    updateHUD(); save();
    state.cook.active=false; state.mode="play";
  }
  function abortCooking(){ state.cook.active=false; state.mode="play"; }

  // ========= Joystick & Keys =========
  const stick=document.getElementById('stick'), knob=document.getElementById('knob');
  function setKnob(dx,dy){ const m=Math.hypot(dx,dy), cl=Math.min(m,state.joy.max); const nx=(dx===0&&dy===0)?0:(dx/m*cl), ny=(dx===0&&dy===0)?0:(dy/m*cl); knob.style.transform=`translate(${nx}px, ${ny}px)`; }
  function joyVecFrom(dx,dy){ const m=Math.hypot(dx,dy); if(m<state.joy.dead) return {vx:0,vy:0}; const s=Math.min(1,m/state.joy.max); return {vx:(dx/m)*s, vy:(dy/m)*s}; }
  stick.addEventListener('touchstart',(e)=>{ const t=e.changedTouches[0]; state.joy.id=t.identifier; const r=stick.getBoundingClientRect(); state.joy.cx=r.left+r.width/2; state.joy.cy=r.top+r.height/2; const dx=t.clientX-state.joy.cx, dy=t.clientY-state.joy.cy; const v=joyVecFrom(dx,dy); state.joy.vx=v.vx; state.joy.vy=v.vy; setKnob(dx,dy); e.preventDefault(); },{passive:false});
  stick.addEventListener('touchmove',(e)=>{ for(const t of e.changedTouches){ if(t.identifier!==state.joy.id) continue; const dx=t.clientX-state.joy.cx, dy=t.clientY-state.joy.cy; const v=joyVecFrom(dx,dy); state.joy.vx=v.vx; state.joy.vy=v.vy; setKnob(dx,dy); e.preventDefault(); } },{passive:false});
  function joyEnd(){ state.joy.id=null; state.joy.vx=0; state.joy.vy=0; setKnob(0,0); }
  stick.addEventListener('touchend',(e)=>{ if([...e.changedTouches].some(t=>t.identifier===state.joy.id)) joyEnd(); },{passive:false});
  stick.addEventListener('touchcancel',(e)=>{ if([...e.changedTouches].some(t=>t.identifier===state.joy.id)) joyEnd(); },{passive:false});
  window.addEventListener('keydown', e=>{
    const k = e.key.toLowerCase();
    state.keys.add(k);
    if (state.cook.active && (k==='escape' || k==='esc')) abortCooking();
  });
  window.addEventListener('keyup',   e=>state.keys.delete(e.key.toLowerCase()));

  // ========= Save/Load =========
  function save(){
    try { localStorage.setItem('mk_save_v7', JSON.stringify({
      inv:state.inv, plants:state.plants, speedMult:state.speedMult, lastTimeBase: state.lastTimeBase, hp: state.hp,
      blocks: state.blocks, god: state.god, shack: state.shack
    })); } catch {}
  }
  (function load(){
    try {
      const d = JSON.parse(localStorage.getItem('mk_save_v7')||"null");
      if (!d) return;
      if (d.inv) state.inv = d.inv;
      if (Array.isArray(d.plants)) state.plants = d.plants;
      if (Array.isArray(d.blocks)) state.blocks = d.blocks;
      if (d.speedMult) state.speedMult = d.speedMult;
      if (d.lastTimeBase) state.lastTimeBase = d.lastTimeBase;
      if (typeof d.hp === "number") state.hp = d.hp;
      if (typeof d.god === "boolean") state.god = d.god;
      if (d.shack) state.shack = d.shack;
    } catch {}
  })();

  // ========= Steinfunktionen =========
  function getNearbyStoneIndex(){ // nat√ºrliche Steine
    let idx=-1, best=1e9;
    const need = state.player.r + STONE_R + 6;
    for (let i=0;i<state.stones.length;i++){
      const s = state.stones[i];
      if (s.type!=='stone') continue;
      const d = dist(s.x,s.y,state.player.x,state.player.y);
      if (d < need && d < best){ best=d; idx=i; }
    }
    return idx;
  }
  function getNearbyPlacedBlockIndex(){ // platzierte Steine
    let idx=-1, best=1e9;
    const need = state.player.r + STONE_R + 6;
    for (let i=0;i<state.blocks.length;i++){
      const b = state.blocks[i];
      const d = dist(b.x,b.y,state.player.x,state.player.y);
      if (d < need && d < best){ best=d; idx=i; }
    }
    return idx;
  }
  function canPlaceStoneAt(tx,ty){
    if (collidesAnyRect(tx,ty)) return false;
    if (Math.hypot(tx - state.player.x, ty - state.player.y) < (state.player.r + STONE_R + 6)) return false; // Anti-Stuck
    for (const s of state.stones) if (s.type==='stone' && dist(tx,ty,s.x,s.y) < STONE_R*2) return false;
    for (const b of state.blocks) if (dist(tx,ty,b.x,b.y) < STONE_R*2) return false;
    if (state.plants.some(p=>dist(tx,ty,p.x,p.y) < STONE_R*2)) return false;
    if (state.shack.built && insideRectPt(tx,ty, state.shack.safeRect)) return false;
    return true;
  }

  // ========= Kontext-Button =========
  function updateContextButton(){
    let icon = "‚ùì", enabled=false, action=null;

    // H√§ndler/Artist/Cheat/Build in N√§he?
    if (state.isDay && isNear(state.merchant)) { icon="üõí"; enabled=true; action=()=>openShop('fecal'); }
    else if (state.isDay && isNear(state.artist)) { icon="üõí"; enabled=true; action=()=>openShop('berta'); }
    else if (isNear(state.cheat)) { icon="üßô‚Äç‚ôÇÔ∏è"; enabled=true; action=()=>openShop('cheat'); }
    else if (isNear(state.toolbox)) { icon="üß∞"; enabled=true; action=()=>openShop('build'); }
    // Kochen: am Feuer
    else if (state.shack.built && state.shack.firePos && dist(state.player.x,state.player.y, state.shack.firePos.x, state.shack.firePos.y) < NEAR_DIST*0.9){
      icon="üç≥"; enabled=true; action=()=>openCookMenu();
    }
    else {
      const p = findNearbyPlant();
      if (p && p.stage>=3){ icon="üåæ"; enabled=true; action=harvestPlant; }
      else if (p && p.stage<3 && state.inv.hasCan && state.inv.can>0 && !p.watered){ icon="üíß"; enabled=true; action=waterPlant; }
      else {
        // 1) platzierten Stein aufheben?
        const bIdx = getNearbyPlacedBlockIndex();
        if (bIdx >= 0){
          icon = "ü™®"; enabled = true;
          action = ()=>{ state.inv.stone++; state.blocks.splice(bIdx,1); updateHUD(); say("ü™® Stein aufgenommen."); save(); };
        } else {
          // 2) nat√ºrlicher Stein?
          const sIdx = getNearbyStoneIndex();
          if (sIdx >= 0){
            icon = "ü™®"; enabled = true;
            action = ()=>{ state.inv.stone++; state.stones.splice(sIdx,1); updateHUD(); say("ü™® Stein aufgenommen."); save(); };
          } else {
            // 3) platzieren?
            const {tx,ty} = snapToTile(state.player.x, state.player.y);
            const tileFreeForPlant = inFarm(tx,ty) && !state.plants.some(pl => dist(pl.x,pl.y,tx,ty) < TILE*0.25) && !isBlockedCircle(tx,ty,TILE*0.2);
            if (state.isDay && tileFreeForPlant && state.activeSeed){
              if (state.activeSeed==="poop" && state.inv.poop>0){ icon="üí©"; enabled=true; action=plantPoop; }
              else if (state.activeSeed==="cabbageSeed" && state.inv.cabbageSeed>0){ icon="ü•¨"; enabled=true; action=plantCabbage; }
            } else if (state.activeSeed==="stone" && state.inv.stone>0){
              if (canPlaceStoneAt(tx,ty)){ icon="üì¶"; enabled=true; action=()=>{ state.inv.stone--; state.blocks.push({x:tx,y:ty}); updateHUD(); say("ü™® platziert."); save(); }; }
            }
          }
        }
      }
    }

    contextBtn.textContent = icon;
    contextBtn.disabled = !enabled;
    contextBtn.onclick = enabled ? action : null;
  }

  // ========= Spawn: Sound + Staub + Position =========
  function spawnDust(x,y){
    for (let i=0;i<14;i++){
      const ang = Math.random()*Math.PI*2, sp = 1.5 + Math.random()*2.2;
      state.spawnFx.push({ x, y, vx: Math.cos(ang)*sp, vy: Math.sin(ang)*sp, r: 2.5 + Math.random()*3, a: 0.9, life: 36 });
    }
  }
  function spawnPlayer(){
    const x = state.clearingRect.x1 + TILE*1.2;
    const y = (state.clearingRect.y1 + state.clearingRect.y2)/2;
    state.player.x = x; state.player.y = y;
    state.player.faceX = 1; state.player.faceY = 0;
    spawnDust(x,y);
    SFX.play.spawn?.();
    say("‚ú® Du bist auf der Lichtung.");
    state.debugCenter = true; // Kamera anpassen
  }

  // ========= Loop =========
  function loop(){
    state.frame++;
    updateClock();

    const paused = state.mode === "cook";

    // Movement + collisions (Spieler)
    if (!paused){
      let vx = state.joy.vx, vy = state.joy.vy;
      if (state.keys.has('arrowup')||state.keys.has('w')) vy -= 1;
      if (state.keys.has('arrowdown')||state.keys.has('s')) vy += 1;
      if (state.keys.has('arrowleft')||state.keys.has('a')) vx -= 1;
      if (state.keys.has('arrowright')||state.keys.has('d')) vx += 1;

      const len=Math.hypot(vx,vy); const speed = SPEED_BASE * state.speedMult * (len>1?1:len);
      let nx=state.player.x, ny=state.player.y;
      if (len>0){
        const tx=clamp(nx + (vx/len)*speed, TILE/2, MAP_W*TILE - TILE/2);
        if (!isBlockedCircle(tx, ny, state.player.r)) nx = tx;
        const ty=clamp(ny + (vy/len)*speed, TILE/2, MAP_H*TILE - TILE/2);
        if (!isBlockedCircle(nx, ty, state.player.r)) ny = ty;
      }
      // Blickrichtung aktualisieren
      const mvx = nx - state.player.x, mvy = ny - state.player.y;
      const mlen = Math.hypot(mvx, mvy);
      if (mlen > 0.01){ state.player.faceX = mvx / mlen; state.player.faceY = mvy / mlen; }
      state.player.x=nx; state.player.y=ny;
    }

    // Camera
    if (state.debugCenter){
      camera.x=clamp(state.player.x - canvas.clientWidth/2, 0, MAP_W*TILE - canvas.clientWidth);
      camera.y=clamp(state.player.y - canvas.clientHeight/2, 0, MAP_H*TILE - canvas.clientHeight);
    }

    // Erdbrocken autopick (mit Poop-Chance)
    if (!paused){
      for (let i=state.stones.length-1;i>=0;i--){
        const s=state.stones[i];
        if (s.type==='dirt' && dist(s.x,s.y,state.player.x,state.player.y) < PICK_DIST*0.8){
          state.stones.splice(i,1);
          if (rand() < ERD_POOP_CHANCE){ state.inv.poop++; say("üí© Gl√ºcksfund im Erdbrocken! +1"); updateHUD(); save(); }
          else say("ü™µ Erdbrocken ‚Äì nix drin.");
        }
      }
      if (state.frame % ROCK_SPAWN === 0 && state.stones.length < ROCK_MAX){ for(let k=0;k<2;k++) spawnRock(); }
    }

    // Pflanzen
    updatePlants();

    // ==== Monster-Logik
    if (!paused){
      if (!state.isDay) {
        state._monsterSpawnTick = (state._monsterSpawnTick||0) + 1;
        if (state._monsterSpawnTick >= MONSTER_SPAWN_INTERVAL && state.monsters.length < MONSTER_MAX) {
          state._monsterSpawnTick = 0;
          const side = Math.floor(rand()*4), margin = TILE*1.0;
          let mx, my;
          if (side===0){ mx=margin; my=rand()*MAP_H*TILE; }
          else if (side===1){ mx=MAP_W*TILE-margin; my=rand()*MAP_H*TILE; }
          else if (side===2){ mx=rand()*MAP_W*TILE; my=margin; }
          else { mx=rand()*MAP_W*TILE; my=MAP_H*TILE-margin; }
          state.monsters.push({ x:mx, y:my, r:TILE*0.35, hp:2 });
        }
      }

      // Monster AI + Safe-Zone
      function blocksSafeZone(x,y,r){ return (!state.isDay && state.shack.built && insideRectPt(x,y, state.shack.safeRect)); }
      for (const m of state.monsters){
        const dx = state.player.x - m.x, dy = state.player.y - m.y;
        const d = Math.hypot(dx,dy) || 1;
        const sp = SPEED_BASE * state.speedMult * MONSTER_SPEED_FACTOR;
        const nx = m.x + (dx/d) * sp;
        const ny = m.y + (dy/d) * sp;
        if (!isBlockedCircle(nx, m.y, m.r) && !blocksSafeZone(nx, m.y, m.r)) m.x = nx;
        if (!isBlockedCircle(m.x, ny, m.r) && !blocksSafeZone(m.x, ny, m.r)) m.y = ny;
      }

      // Monster ‚Üî Spieler Kollision
      for (const m of state.monsters){
        const d = Math.hypot(state.player.x - m.x, state.player.y - m.y);
        if (d < (state.player.r + m.r)){
          const now = time.now();
          if (now >= state.invincibleUntil && !state.god){
            state.hp = Math.max(0, state.hp - 1);
            state.invincibleUntil = now + MONSTER_DAMAGE_COOLDOWN;
            const kx = (state.player.x - m.x) / (d || 1), ky = (state.player.y - m.y) / (d || 1);
            state.player.x += kx * MONSTER_TOUCH_KNOCKBACK; state.player.y += ky * MONSTER_TOUCH_KNOCKBACK;
            say(`üí• Treffer! Leben: ${state.hp}`);
            if (state.hp <= 0){
              // Respawn bei Tod
              state.hp = 3; state.monsters.length=0;
              spawnPlayer();
            }
          }
        }
      }

      // BULLETS
      const nowB = time.now();
      for (let i = state.bullets.length-1; i>=0; i--){
        const b = state.bullets[i];
        if (nowB >= b.dieAt){ state.bullets.splice(i,1); continue; }
        let nx = b.x + b.vx, ny = b.y + b.vy;
        let stopped = false;
        for (const bl of state.blocks){ if (Math.hypot(nx - bl.x, ny - bl.y) < STONE_R){ stopped = true; break; } }
        if (!stopped){
          for (const s of state.stones){ if (s.type==='stone' && Math.hypot(nx - s.x, ny - s.y) < STONE_R){ stopped = true; break; } }
        }
        if (stopped){ state.bullets.splice(i,1); continue; }
        b.x = nx; b.y = ny;
        let hit = false;
        for (let j = state.monsters.length-1; j>=0; j--){
          const m = state.monsters[j];
          if (Math.hypot(b.x - m.x, b.y - m.y) < m.r){
            hit = true;
            state.bullets.splice(i,1);
            m.hp -= 1;
            if (m.hp <= 0){
              const roll = rand();
              if (roll < 0.33){ state.inv.poop += 1; say("üí© Beute!"); }
              else if (roll < 0.66){ state.inv.cabbageSeed += 1; say("ü•¨ Saat-Beute!"); }
              else { const euro = 1 + Math.floor(rand()*3); state.inv.euro += euro; say(`üí∂ +${euro}‚Ç¨ Beute!`); }
              state.monsters.splice(j,1);
              updateHUD(); save();
            }
            break;
          }
        }
        if (hit) continue;
      }
    }

    // Rauchentwicklung am Haus
    if (state.frame % 20 === 0) pushSmoke();

    // Cooking pointer anim
    if (state.cook.active){
      state.cook.pos += state.cook.dir * state.cook.speed;
      if (state.cook.pos <= 0){ state.cook.pos = 0; state.cook.dir = 1; }
      if (state.cook.pos >= 1){ state.cook.pos = 1; state.cook.dir = -1; }
    }

    // Spawn-Staub updaten
    for (let i=state.spawnFx.length-1; i>=0; i--){
      const p = state.spawnFx[i];
      p.x += p.vx; p.y += p.vy;
      p.vx *= 0.92; p.vy *= 0.92;
      p.a *= 0.96; p.life--;
      if (p.life<=0 || p.a<0.05) state.spawnFx.splice(i,1);
    }

    draw();
    updateHUD();
    if (!paused) updateContextButton();
    requestAnimationFrame(loop);
  }

  // ========= Click interactions =========
  canvas.addEventListener('click', (e)=>{
    if (state.cook.active){ stopCookingHit(); return; }

    const rect = canvas.getBoundingClientRect();
    const gx = (e.clientX - rect.left) + camera.x;
    const gy = (e.clientY - rect.top) + camera.y;

    // Blick zum Klick ausrichten (nachts beim Schie√üen n√ºtzlich)
    const dirx = gx - state.player.x, diry = gy - state.player.y;
    const dlen = Math.hypot(dirx, diry) || 1;
    state.player.faceX = dirx / dlen; state.player.faceY = diry / dlen;

    // nachts: schie√üen
    if (!state.isDay){
      if (state.inv.stone > 0){
        const dx = gx - state.player.x, dy = gy - state.player.y, d = Math.hypot(dx,dy) || 1;
        const vx = (dx/d) * BULLET_SPEED, vy = (dy/d) * BULLET_SPEED;
        state.inv.stone -= 1;
        state.bullets.push({ x:state.player.x, y:state.player.y, vx, vy, dieAt: time.now() + BULLET_LIFE });
        updateHUD(); return;
      } else { say("ü™® Keine Steine zum Schie√üen!"); }
    }

    // tags√ºber: H√§ndler/Teich/Cheat/Build
    if (isNear(state.merchant)) openShop('fecal');
    else if (isNear(state.artist)) openShop('berta');
    else if (isNear(state.cheat)) openShop('cheat');
    else if (isNear(state.toolbox)) openShop('build');
    else if (state.shack.built && state.shack.firePos && dist(state.player.x,state.player.y, state.shack.firePos.x, state.shack.firePos.y) < NEAR_DIST*0.9){
      openCookMenu();
    }
    else if (isNear(state.pond, POND_DIST)){
      if (!state.inv.hasCan) return say("Keine Gie√ükanne.");
      if (!state.isDay) return say("Nacht: Der Teich ist still‚Ä¶");
      state.inv.can = state.inv.canMax; updateHUD(); say("üíß Gie√ükanne aufgef√ºllt!"); save();
    }
  });

  // ========= Smoke =========
  function pushSmoke(){
    const hy = state.merchant.y - TILE;
    const sx = state.merchant.x + TILE*0.7, sy = hy - TILE*0.95;
    state.smoke.push({ x:sx, y:sy, r:4+rand()*5, a: state.isDay ? 0.6 : 0.85, vy:-0.3-rand()*0.2 });
    state.smoke = state.smoke.filter(s => s.a > 0.05);
  }

  // ========= Draw =========
  function drawFenceWithGate(f){
    const gateCenter = (f.x1 + f.x2) / 2;
    const gateLeft = gateCenter - GATE_WIDTH/2, gateRight = gateCenter + GATE_WIDTH/2;
    state.fenceRects = []; const t = FENCE_THICK;
    const push = (x1,y1,x2,y2)=> state.fenceRects.push({x1,y1,x2,y2});
    push(f.x1 - t, f.y1 - t, f.x2 + t, f.y1 + t);
    push(f.x1 - t, f.y2 - t, gateLeft, f.y2 + t);
    push(gateRight, f.y2 - t, f.x2 + t, f.y2 + t);
    push(f.x1 - t, f.y1 - t, f.x1 + t, f.y2 + t);
    push(f.x2 - t, f.y1 - t, f.x2 + t, f.y2 + t);

    // Visuals
    ctx.fillStyle = "rgba(120, 220, 140, 0.14)"; ctx.fillRect(f.x1, f.y1, f.x2-f.x1, f.y2-f.y1);
    ctx.strokeStyle = "#916c3b"; ctx.lineWidth = 4;
    ctx.beginPath(); ctx.moveTo(f.x1, f.y1); ctx.lineTo(f.x2, f.y1); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(f.x1, f.y2); ctx.lineTo(gateLeft, f.y2); ctx.moveTo(gateRight, f.y2); ctx.lineTo(f.x2, f.y2); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(f.x1, f.y1); ctx.lineTo(f.x1, f.y2); ctx.moveTo(f.x2, f.y1); ctx.lineTo(f.x2, f.y2); ctx.stroke();
    ctx.lineWidth = 3; ctx.beginPath();
    ctx.moveTo(f.x1, f.y1+TILE*0.35); ctx.lineTo(f.x2, f.y1+TILE*0.35);
    ctx.moveTo(f.x1, f.y2-TILE*0.35); ctx.lineTo(gateLeft, f.y2-TILE*0.35);
    ctx.moveTo(gateRight, f.y2-TILE*0.35); ctx.lineTo(f.x2, f.y2-TILE*0.35); ctx.stroke();
    ctx.fillStyle = "#a77b44";
    for (let x=f.x1; x<=f.x2; x+=TILE){ ctx.fillRect(x-3, f.y1-6, 6, 12); ctx.fillRect(x-3, f.y2-6, 6, 12); }
    for (let y=f.y1; y<=f.y2; y+=TILE){ ctx.fillRect(f.x1-6, y-3, 12, 6); ctx.fillRect(f.x2-6, y-3, 12, 6); }
    ctx.fillRect(gateLeft-4,  f.y2-10, 8, 20); ctx.fillRect(gateRight-4, f.y2-10, 8, 20);
  }

  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.save(); ctx.translate(-camera.x, -camera.y);

    // Hintergrund
    const bgA = state.isDay ? "#0d3316" : "#08190c", bgB = state.isDay ? "#12401e" : "#0c2013";
    for (let y=0;y<MAP_H;y++) for (let x=0;x<MAP_W;x++){ const px=x*TILE, py=y*TILE; ctx.fillStyle = ((x+y)%2===0)?bgA:bgB; ctx.fillRect(px,py,TILE,TILE); }

    // Lichtung
    const clr = state.clearingRect;
    ctx.fillStyle = "#1a5a2d"; ctx.fillRect(clr.x1, clr.y1, clr.x2-clr.x1, clr.y2-clr.y1);
    ctx.strokeStyle = "rgba(180,220,150,0.35)"; ctx.strokeRect(clr.x1, clr.y1, clr.x2-clr.x1, clr.y2-clr.y1);

    // Farm-Feld mit Zaun
    drawFenceWithGate(state.farmRect);

    // Fecalfreds Haus
    const hx=state.merchant.x - TILE, hy=state.merchant.y - TILE;
    ctx.fillStyle="#6b4630"; state.houseRect && ctx.fillRect(state.houseRect.x1, state.houseRect.y1, state.houseRect.x2-state.houseRect.x1, state.houseRect.y2-state.houseRect.y1);
    ctx.fillStyle="#9b3b2e"; ctx.fillRect(hx - TILE*0.5, hy - TILE*0.95, TILE*2, TILE*0.45);
    ctx.fillStyle="rgba(0,0,0,0.15)"; for (let i=0;i<12;i++){ ctx.fillRect(hx - TILE*0.5 + i*TILE*0.16, hy - TILE*0.95, TILE*0.12, TILE*0.45); }
    ctx.fillStyle="#2b1c11"; ctx.fillRect(hx + TILE*0.2, hy + TILE*0.5, TILE*0.5, TILE*0.7);
    const signW = TILE*2.8, signH = TILE*0.75;
    ctx.fillStyle="#f8f5e7"; ctx.fillRect(state.merchant.x - signW/2, hy + TILE*1.25, signW, signH);
    ctx.fillStyle="#2b2b2b"; ctx.font = `bold ${Math.floor(TILE*0.38)}px system-ui`; ctx.textAlign="center"; ctx.textBaseline="middle"; ctx.fillText("FECALFRED", state.merchant.x, hy + TILE*1.25 + signH/2);
    ctx.font = `${Math.floor(TILE*0.9)}px system-ui`; ctx.fillText("üßë‚Äçüåæ", state.merchant.x, state.merchant.y - TILE*0.5);

    // Berta Brown
    const ax = state.artist.x, ay = state.artist.y;
    ctx.fillStyle="#8b5a2b"; ctx.fillRect(ax - TILE*0.8, ay - TILE*0.6, TILE*0.15, TILE*1.3); ctx.fillRect(ax + TILE*0.65, ay - TILE*0.6, TILE*0.15, TILE*1.3);
    ctx.fillStyle="#f0e0c0"; ctx.fillRect(ax - TILE*0.5, ay - TILE*0.9, TILE*1.1, TILE*0.8);
    ctx.fillStyle="#d88"; ctx.fillRect(ax - TILE*0.48, ay - TILE*0.88, TILE*0.52, TILE*0.3); ctx.fillStyle="#8ad"; ctx.fillRect(ax + TILE*0.08, ay - TILE*0.88, TILE*0.5, TILE*0.3);
    ctx.fillStyle="#444"; ctx.fillRect(ax - TILE*0.48, ay - TILE*0.5, TILE*1.06, TILE*0.38);
    ctx.fillStyle="#f8f5e7"; ctx.fillRect(ax - TILE*1.2, ay + TILE*0.8, TILE*2.4, TILE*0.45);
    ctx.fillStyle="#2b2b2b"; ctx.font = `bold ${Math.floor(TILE*0.34)}px system-ui`; ctx.fillText("BERTA BROWN", ax, ay + TILE*1.02);
    ctx.font = `${Math.floor(TILE*0.9)}px system-ui`; ctx.fillText("üë©‚Äçüé®", ax, ay - TILE*0.5);

    // Stefan Spielverderber ‚Äì goldenes Haus
    const cx = state.cheat.x, cy = state.cheat.y;
    ctx.fillStyle = "#9c7a00"; ctx.fillRect(cx - TILE*0.9, cy - TILE*0.9, TILE*1.8, TILE*1.1);
    ctx.fillStyle = "#ffd54a"; ctx.fillRect(cx - TILE*1.2, cy - TILE*1.25, TILE*2.4, TILE*0.5);
    ctx.fillStyle = "#2b1c11"; ctx.fillRect(cx - TILE*0.2, cy - TILE*0.1, TILE*0.4, TILE*0.6);
    ctx.fillStyle="#f8f5e7"; ctx.fillRect(cx - TILE*1.4, cy + TILE*0.8, TILE*2.8, TILE*0.45);
    ctx.fillStyle="#2b2b2b"; ctx.font = `bold ${Math.floor(TILE*0.32)}px system-ui`; ctx.textAlign="center"; ctx.textBaseline="middle";
    ctx.fillText("STEFAN SPIELVERDERBER", cx, cy + TILE*1.02);
    ctx.font = `${Math.floor(TILE*0.9)}px system-ui`; ctx.fillText("üßô‚Äç‚ôÇÔ∏è", cx, cy - TILE*0.5);

    // Pond
    const px = state.pond.x, py = state.pond.y; const pondW=TILE*2.4, pondH=TILE*1.6;
    ctx.fillStyle="#1b4d6b"; ctx.beginPath(); ctx.ellipse(px, py, pondW, pondH, 0, 0, Math.PI*2); ctx.fill();
    ctx.strokeStyle="rgba(180,220,255,0.25)"; ctx.lineWidth=2; for(let i=0;i<5;i++){ ctx.beginPath(); ctx.ellipse(px, py, pondW*0.8*(i+1)/5, pondH*0.8*(i+1)/5, 0, 0, Math.PI*2); ctx.stroke(); }
    ctx.fillStyle="#2e6b2e"; for(let i=-2;i<=2;i++){ ctx.fillRect(px + i*20, py+pondH-6, 4, 16); }

    // nat√ºrliche Steine / Erdbrocken
    for (const s of state.stones){
      if (s.type==='stone'){
        ctx.fillStyle="#b9c2cc"; ctx.beginPath(); ctx.ellipse(s.x, s.y, STONE_R, STONE_R*0.78, 0, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle="#88929e"; ctx.beginPath(); ctx.ellipse(s.x - TILE*0.12, s.y - TILE*0.08, TILE*0.12, TILE*0.09, 0, 0, Math.PI*2); ctx.fill();
      } else {
        ctx.fillStyle="#7a5a3a"; ctx.beginPath(); ctx.ellipse(s.x, s.y, TILE*0.34, TILE*0.26, 0.2, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle="#5c4128"; ctx.beginPath(); ctx.ellipse(s.x - TILE*0.08, s.y - TILE*0.05, TILE*0.1, TILE*0.08, -0.2, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle="#4a3521"; ctx.beginPath(); ctx.arc(s.x+TILE*0.12, s.y+TILE*0.05, 2.2, 0, Math.PI*2); ctx.fill(); ctx.arc(s.x-TILE*0.14, s.y+TILE*0.04, 1.8, 0, Math.PI*2); ctx.fill();
      }
    }

    // platzierte Steine (Blocks)
    for (const bl of state.blocks){
      ctx.fillStyle="#8d97a3"; ctx.beginPath(); ctx.ellipse(bl.x, bl.y, STONE_R, STONE_R*0.78, 0, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle="#6f7a86"; ctx.beginPath(); ctx.ellipse(bl.x - TILE*0.12, bl.y - TILE*0.08, TILE*0.12, TILE*0.09, 0, 0, Math.PI*2); ctx.fill();
    }

    // Plants
    for (const p of state.plants){
      if (p.type==='corn'){
        ctx.fillStyle="#382a1d"; ctx.beginPath(); ctx.arc(p.x,p.y,TILE*0.28,0,Math.PI*2); ctx.fill();
        if (p.stage===0){ ctx.fillStyle="#63d16e"; ctx.fillRect(p.x-TILE*0.08, p.y-TILE*0.10, TILE*0.16, TILE*0.10); }
        else if (p.stage===1){ ctx.fillStyle="#58b368"; ctx.fillRect(p.x-TILE*0.12, p.y-TILE*0.20, TILE*0.24, TILE*0.22); }
        else if (p.stage===2){ ctx.save(); ctx.translate(p.x,p.y); ctx.fillStyle="#f2d24b"; ctx.beginPath(); ctx.ellipse(0,-TILE*0.05, TILE*0.10, TILE*0.20, 0, 0, Math.PI*2); ctx.fill(); ctx.fillStyle="#5cbc6b"; ctx.beginPath(); ctx.moveTo(-TILE*0.18,0); ctx.quadraticCurveTo(0,-TILE*0.30, TILE*0.18,0); ctx.quadraticCurveTo(0,TILE*0.05, -TILE*0.18,0); ctx.fill(); ctx.restore(); }
        else { ctx.save(); ctx.translate(p.x,p.y); ctx.fillStyle="#f2d24b"; ctx.beginPath(); ctx.ellipse(0,-TILE*0.05, TILE*0.16, TILE*0.26, 0, 0, Math.PI*2); ctx.fill(); ctx.fillStyle="#5cbc6b"; ctx.beginPath(); ctx.moveTo(-TILE*0.22,0); ctx.quadraticCurveTo(0,-TILE*0.35, TILE*0.22,0); ctx.quadraticCurveTo(0,TILE*0.05, -TILE*0.22,0); ctx.fill(); ctx.restore(); }
      } else {
        ctx.fillStyle="#352519"; ctx.beginPath(); ctx.arc(p.x,p.y,TILE*0.28,0,Math.PI*2); ctx.fill();
        if (p.stage===0){ ctx.fillStyle="#4e8f4e"; ctx.beginPath(); ctx.arc(p.x, p.y, TILE*0.10, 0, Math.PI*2); ctx.fill(); }
        else if (p.stage===1){ ctx.fillStyle="#4fa65b"; ctx.beginPath(); ctx.arc(p.x, p.y, TILE*0.16, 0, Math.PI*2); ctx.fill(); ctx.fillStyle="#3d7f43"; ctx.beginPath(); ctx.arc(p.x-6, p.y-2, 5, 0, Math.PI*2); ctx.fill(); ctx.arc(p.x+6, p.y+3, 4, 0, Math.PI*2); ctx.fill(); }
        else if (p.stage===2){ ctx.fillStyle="#58bb68"; ctx.beginPath(); ctx.arc(p.x, p.y, TILE*0.22, 0, Math.PI*2); ctx.fill(); ctx.fillStyle="#3d944a"; ctx.beginPath(); ctx.arc(p.x-8, p.y, 6, 0, Math.PI*2); ctx.fill(); ctx.arc(p.x+8, p.y, 6, 0, Math.PI*2); ctx.fill(); }
        else { ctx.fillStyle="#6bd17a"; ctx.beginPath(); ctx.arc(p.x, p.y, TILE*0.26, 0, Math.PI*2); ctx.fill(); ctx.fillStyle="#44a457"; ctx.beginPath(); ctx.arc(p.x-9, p.y-2, 7, 0, Math.PI*2); ctx.fill(); ctx.arc(p.x+9, p.y+2, 7, 0, Math.PI*2); ctx.fill(); ctx.fillStyle="rgba(255,255,255,0.08)"; ctx.beginPath(); ctx.arc(p.x, p.y-5, 8, 0, Math.PI*2); ctx.fill(); }
      }
    }

    // Monster (mit Blickrichtung)
    for (const m of state.monsters){
      const dx = state.player.x - m.x, dy = state.player.y - m.y;
      const d = Math.hypot(dx,dy) || 1;
      const fx = dx/d, fy = dy/d;
      const sideX = -fy, sideY = fx;
      const eyeOff = 5, eyeR = 3;

      ctx.save(); ctx.translate(m.x, m.y);
      ctx.fillStyle = state.isDay ? "#444" : "#5f1044"; ctx.beginPath(); ctx.arc(0,0,m.r,0,Math.PI*2); ctx.fill();

      const ex = fx * (m.r*0.3), ey = fy * (m.r*0.3);
      const Lx = ex + sideX * eyeOff, Ly = ey + sideY * eyeOff;
      const Rx = ex - sideX * eyeOff, Ry = ey - sideY * eyeOff;

      ctx.fillStyle="#fff"; ctx.beginPath(); ctx.arc(Lx, Ly, eyeR+1, 0, Math.PI*2); ctx.arc(Rx, Ry, eyeR+1, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle="#111"; ctx.beginPath(); ctx.arc(Lx + fx*2, Ly + fy*2, eyeR, 0, Math.PI*2); ctx.arc(Rx + fx*2, Ry + fy*2, eyeR, 0, Math.PI*2); ctx.fill();
      ctx.restore();
    }

    // Spieler (mit Blickrichtung)
    {
      const fdx = state.player.faceX, fdy = state.player.faceY;
      const eyeOff = 6, eyeR = state.player.r*0.11;
      const sideX = -fdy, sideY = fdx;
      const eyeBaseX = state.player.x + fdx * (state.player.r*0.25);
      const eyeBaseY = state.player.y + fdy * (state.player.r*0.25);
      const Lx = eyeBaseX + sideX * eyeOff, Ly = eyeBaseY + sideY * eyeOff;
      const Rx = eyeBaseX - sideX * eyeOff, Ry = eyeBaseY - sideY * eyeOff;

      ctx.fillStyle="#e6b35a"; ctx.beginPath(); ctx.arc(state.player.x, state.player.y, state.player.r, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle="#fff"; ctx.beginPath(); ctx.arc(Lx, Ly, eyeR, 0, Math.PI*2); ctx.arc(Rx, Ry, eyeR, 0, Math.PI*2); ctx.fill();
      const pupOff = eyeR*0.6; ctx.fillStyle="#111"; ctx.beginPath();
      ctx.arc(Lx + fdx*pupOff, Ly + fdy*pupOff, eyeR*0.55, 0, Math.PI*2);
      ctx.arc(Rx + fdx*pupOff, Ry + fdy*pupOff, eyeR*0.55, 0, Math.PI*2); ctx.fill();
      ctx.strokeStyle="#111"; ctx.lineWidth=3; ctx.beginPath();
      const mx = state.player.x + fdx*(state.player.r*0.55);
      const my = state.player.y + fdy*(state.player.r*0.55);
      ctx.moveTo(mx - sideX*6, my - sideY*6);
      ctx.lineTo(mx + sideX*6, my + sideY*6);
      ctx.stroke();
    }

    // Projektile
    ctx.fillStyle="#b9c2cc";
    for (const b of state.bullets){ ctx.beginPath(); ctx.ellipse(b.x, b.y, 6, 4, 0, 0, Math.PI*2); ctx.fill(); }

    // Nacht-Overlay
    if (!state.isDay){ ctx.fillStyle="rgba(0,0,0,0.35)"; ctx.fillRect(camera.x, camera.y, canvas.clientWidth, canvas.clientHeight); }

    // Schornsteinrauch
    const hy2=state.merchant.y - TILE; const cx2 = state.merchant.x + TILE*0.7, cy2 = hy2 - TILE*0.95;
    ctx.fillStyle="#4b2f1b"; ctx.fillRect(cx2, cy2 - TILE*0.2, TILE*0.25, TILE*0.35);
    for (const s of state.smoke){ s.x += 0.05; s.y += s.vy; s.a *= 0.985; s.r = (s.r||5)*1.01; ctx.fillStyle=`rgba(220,220,220,${s.a})`; ctx.beginPath(); ctx.arc(s.x, s.y, s.r, 0, Math.PI*2); ctx.fill(); }

    // Werkzeugkasten (wenn kein Shack)
    if (!state.shack.built){
      const bx = state.toolbox.x, by = state.toolbox.y;
      ctx.fillStyle = "#6d4c33"; ctx.fillRect(bx - TILE*0.35, by - TILE*0.25, TILE*0.7, TILE*0.5);
      ctx.fillStyle = "#8a6145"; ctx.fillRect(bx - TILE*0.32, by - TILE*0.22, TILE*0.64, TILE*0.18);
      ctx.fillStyle = "#222"; ctx.font = `bold ${Math.floor(TILE*0.6)}px system-ui`;
      ctx.textAlign="center"; ctx.textBaseline="middle"; ctx.fillText("üîß", bx, by - TILE*0.1);
    }

    // Shack & Sicherheitszone
    if (state.shack.built){
      const z = state.shack.safeRect;
      ctx.strokeStyle = "rgba(250, 230, 120, 0.35)"; ctx.lineWidth = 3; ctx.strokeRect(z.x1, z.y1, z.x2 - z.x1, z.y2 - z.y1);
      const cx = (z.x1+z.x2)/2, cy = (z.y1+z.y2)/2;
      ctx.fillStyle = "#70553b"; ctx.fillRect(cx - TILE*0.9, cy - TILE*0.7, TILE*1.8, TILE*1.2);
      ctx.fillStyle = "#8a6a4b"; ctx.fillRect(cx - TILE*1.1, cy - TILE*1.0, TILE*2.2, TILE*0.5);
      ctx.fillStyle = "#2b1c11"; ctx.fillRect(cx - TILE*0.15, cy - TILE*0.1, TILE*0.3, TILE*0.6);
      ctx.fillStyle = "#d7e7ff"; ctx.fillRect(cx + TILE*0.45, cy - TILE*0.2, TILE*0.35, TILE*0.3);
      const fx = cx - TILE*0.7, fy = cy + TILE*0.4;
      if (!state.shack.firePos) state.shack.firePos = {x:fx, y:fy};
      ctx.fillStyle="#3a2a1d"; ctx.beginPath(); ctx.arc(fx,fy, TILE*0.2, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle="#ffb84d"; ctx.beginPath(); ctx.arc(fx,fy-6, TILE*0.14, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle="rgba(255,255,255,0.3)"; ctx.beginPath(); ctx.arc(fx,fy-12, TILE*0.09, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle="#c7d2fe"; ctx.fillRect(cx + TILE*0.3, cy + TILE*0.25, TILE*0.8, TILE*0.22);
      ctx.fillStyle="#93c5fd"; ctx.fillRect(cx + TILE*0.3, cy + TILE*0.1, TILE*0.35, TILE*0.15);
    }

    // Platzierungs-Vorschau
    if (state.activeSeed==="stone" && state.inv.stone>0){
      const {tx,ty} = snapToTile(state.player.x, state.player.y);
      const ok = canPlaceStoneAt(tx,ty);
      ctx.save(); ctx.globalAlpha = 0.6;
      ctx.fillStyle = ok ? "rgba(56, 189, 248, 0.35)" : "rgba(239, 68, 68, 0.45)";
      ctx.beginPath(); ctx.ellipse(tx, ty, STONE_R, STONE_R*0.78, 0, 0, Math.PI*2); ctx.fill();
      ctx.restore();
    }

    ctx.restore();

    // ===== Spawn-Staub im Bildschirm-KS (Additiv) =====
    ctx.save();
    ctx.translate(-camera.x, -camera.y);
    ctx.globalCompositeOperation='lighter';
    for (const p of state.spawnFx){
      ctx.fillStyle=`rgba(240,220,180,${p.a})`;
      ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, Math.PI*2); ctx.fill();
    }
    ctx.restore();

    // ===== Cooking Overlay =====
    if (state.cook.active){
      ctx.fillStyle="rgba(0,0,0,0.65)";
      ctx.fillRect(0,0,canvas.clientWidth, canvas.clientHeight);

      const W = Math.min(520, canvas.clientWidth*0.9), H = 200;
      const x = (canvas.clientWidth - W)/2, y = (canvas.clientHeight - H)/2;

      ctx.fillStyle="#0f141a"; ctx.fillRect(x, y, W, H);
      ctx.strokeStyle="#3a2a18"; ctx.lineWidth=3; ctx.strokeRect(x, y, W, H);

      ctx.fillStyle="#f2f2f2"; ctx.font=`bold 18px system-ui`;
      ctx.fillText(`Kochen: ${state.cook.item==='corn'?'Mais':'Kohl'} ‚Äî Runde ${state.cook.round}/3`, x+14, y+26);
      ctx.font=`12px system-ui`; ctx.fillStyle="#cbd5e1";
      ctx.fillText("Tippen um den Zeiger im gr√ºnen Bereich zu stoppen", x+14, y+46);

      const barX = x+24, barY = y+90, barW = W-48, barH = 18;
      ctx.fillStyle="#334155"; ctx.fillRect(barX, barY, barW, barH);

      const ga = barX + state.cook.green[0]*barW;
      const gb = barX + state.cook.green[1]*barW;
      ctx.fillStyle="#22c55e"; ctx.fillRect(ga, barY, gb-ga, barH);

      const pxp = barX + state.cook.pos * barW;
      ctx.fillStyle="#eab308"; ctx.fillRect(pxp-2, barY-10, 4, barH+20);

      ctx.fillStyle="#94a3b8"; ctx.font='12px system-ui';
      ctx.fillText(`Treffer bisher: ${state.cook.successes}`, x+14, y+H-18);
    }
  }

  // ========= Helpers =========
  btnCenter.addEventListener('click', ()=>{ state.debugCenter=true; say("Ansicht zentriert."); });
  btnReset .addEventListener('click', ()=>{ localStorage.removeItem('mk_save_v7'); location.reload(); }); // Neustart via Reload (Spawn erfolgt beim Start)

  // ========= Start =========
  updateHUD();
  spawnPlayer();    // Spawn-Sound + Staub + Lichtungs-Start
  loop();
})();
</script>
</body>
</html>
